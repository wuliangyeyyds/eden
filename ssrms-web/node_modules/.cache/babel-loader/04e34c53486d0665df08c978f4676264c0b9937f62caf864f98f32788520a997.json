{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport { ref, getCurrentInstance, watch, nextTick } from 'vue';\nimport { NODE_CHECK, NODE_CHECK_CHANGE, SetOperationEnum } from '../virtual-tree.mjs';\nfunction useCheck(props, tree) {\n  const checkedKeys = ref(/* @__PURE__ */new Set());\n  const indeterminateKeys = ref(/* @__PURE__ */new Set());\n  const {\n    emit\n  } = getCurrentInstance();\n  watch([() => tree.value, () => props.defaultCheckedKeys], () => {\n    return nextTick(() => {\n      _setCheckedKeys(props.defaultCheckedKeys);\n    });\n  }, {\n    immediate: true\n  });\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return;\n    }\n    const {\n      levelTreeNodeMap,\n      maxLevel\n    } = tree.value;\n    const checkedKeySet = checkedKeys.value;\n    const indeterminateKeySet = /* @__PURE__ */new Set();\n    for (let level = maxLevel; level >= 1; --level) {\n      const nodes = levelTreeNodeMap.get(level);\n      if (!nodes) continue;\n      nodes.forEach(node => {\n        const children = node.children;\n        let isEffectivelyChecked = !node.isLeaf || node.disabled || checkedKeySet.has(node.key);\n        if (children) {\n          let allChecked = true;\n          let hasChecked = false;\n          for (const childNode of children) {\n            const key = childNode.key;\n            if (!childNode.isEffectivelyChecked) {\n              isEffectivelyChecked = false;\n            }\n            if (checkedKeySet.has(key)) {\n              hasChecked = true;\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false;\n              hasChecked = true;\n              break;\n            } else {\n              allChecked = false;\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key);\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key);\n            checkedKeySet.delete(node.key);\n          } else {\n            checkedKeySet.delete(node.key);\n            indeterminateKeySet.delete(node.key);\n          }\n        }\n        node.isEffectivelyChecked = isEffectivelyChecked;\n      });\n    }\n    indeterminateKeys.value = indeterminateKeySet;\n  };\n  const isChecked = node => checkedKeys.value.has(node.key);\n  const isIndeterminate = node => indeterminateKeys.value.has(node.key);\n  const toggleCheckbox = (node, isChecked2, nodeClick = true, immediateUpdate = true) => {\n    const checkedKeySet = checkedKeys.value;\n    const children = node.children;\n    if (!props.checkStrictly && nodeClick && (children == null ? void 0 : children.length)) {\n      isChecked2 = children.some(node2 => !node2.isEffectivelyChecked);\n    }\n    const toggle = (node2, checked) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](node2.key);\n      const children2 = node2.children;\n      if (!props.checkStrictly && children2) {\n        children2.forEach(childNode => {\n          if (!childNode.disabled || childNode.children) {\n            toggle(childNode, checked);\n          }\n        });\n      }\n    };\n    toggle(node, isChecked2);\n    if (immediateUpdate) {\n      updateCheckedKeys();\n    }\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked2);\n    }\n  };\n  const afterNodeCheck = (node, checked) => {\n    const {\n      checkedNodes,\n      checkedKeys: checkedKeys2\n    } = getChecked();\n    const {\n      halfCheckedNodes,\n      halfCheckedKeys\n    } = getHalfChecked();\n    emit(NODE_CHECK, node.data, {\n      checkedKeys: checkedKeys2,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes\n    });\n    emit(NODE_CHECK_CHANGE, node.data, checked);\n  };\n  function getCheckedKeys(leafOnly = false) {\n    return getChecked(leafOnly).checkedKeys;\n  }\n  function getCheckedNodes(leafOnly = false) {\n    return getChecked(leafOnly).checkedNodes;\n  }\n  function getHalfCheckedKeys() {\n    return getHalfChecked().halfCheckedKeys;\n  }\n  function getHalfCheckedNodes() {\n    return getHalfChecked().halfCheckedNodes;\n  }\n  function getChecked(leafOnly = false) {\n    const checkedNodes = [];\n    const keys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      checkedKeys.value.forEach(key => {\n        const node = treeNodeMap.get(key);\n        if (node && (!leafOnly || leafOnly && node.isLeaf)) {\n          keys.push(key);\n          checkedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes\n    };\n  }\n  function getHalfChecked() {\n    const halfCheckedNodes = [];\n    const halfCheckedKeys = [];\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      indeterminateKeys.value.forEach(key => {\n        const node = treeNodeMap.get(key);\n        if (node) {\n          halfCheckedKeys.push(key);\n          halfCheckedNodes.push(node.data);\n        }\n      });\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys\n    };\n  }\n  function setCheckedKeys(keys) {\n    checkedKeys.value.clear();\n    indeterminateKeys.value.clear();\n    nextTick(() => {\n      _setCheckedKeys(keys);\n    });\n  }\n  function setChecked(key, isChecked2) {\n    if ((tree == null ? void 0 : tree.value) && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key);\n      if (node) {\n        toggleCheckbox(node, isChecked2, false);\n      }\n    }\n  }\n  function _setCheckedKeys(keys) {\n    if (tree == null ? void 0 : tree.value) {\n      const {\n        treeNodeMap\n      } = tree.value;\n      if (props.showCheckbox && treeNodeMap && (keys == null ? void 0 : keys.length) > 0) {\n        for (const key of keys) {\n          const node = treeNodeMap.get(key);\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false, false);\n          }\n        }\n        updateCheckedKeys();\n      }\n    }\n  }\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys\n  };\n}\nexport { useCheck };","map":{"version":3,"names":["useCheck","props","tree","checkedKeys","ref","Set","indeterminateKeys","emit","getCurrentInstance","watch","value","defaultCheckedKeys","nextTick","_setCheckedKeys","immediate","updateCheckedKeys","showCheckbox","checkStrictly","levelTreeNodeMap","maxLevel","checkedKeySet","indeterminateKeySet","level","nodes","get","forEach","node","children","isEffectivelyChecked","isLeaf","disabled","has","key","allChecked","hasChecked","childNode","add","delete","isChecked","isIndeterminate","toggleCheckbox","isChecked2","nodeClick","immediateUpdate","length","some","node2","toggle","checked","SetOperationEnum","ADD","DELETE","children2","afterNodeCheck","checkedNodes","checkedKeys2","getChecked","halfCheckedNodes","halfCheckedKeys","getHalfChecked","NODE_CHECK","data","NODE_CHECK_CHANGE","getCheckedKeys","leafOnly","getCheckedNodes","getHalfCheckedKeys","getHalfCheckedNodes","keys","treeNodeMap","push","setCheckedKeys","clear","setChecked"],"sources":["../../../../../../../packages/components/tree-v2/src/composables/useCheck.ts"],"sourcesContent":["import { getCurrentInstance, nextTick, ref, watch } from 'vue'\nimport {\n  NODE_CHECK,\n  NODE_CHECK_CHANGE,\n  SetOperationEnum,\n} from '../virtual-tree'\n\nimport type { CheckboxValueType } from '@element-plus/components/checkbox'\nimport type { Ref } from 'vue'\nimport type { Tree, TreeKey, TreeNode, TreeNodeData, TreeProps } from '../types'\n\nexport function useCheck(props: TreeProps, tree: Ref<Tree | undefined>) {\n  const checkedKeys = ref<Set<TreeKey>>(new Set())\n  const indeterminateKeys = ref<Set<TreeKey>>(new Set())\n  const { emit } = getCurrentInstance()!\n\n  watch(\n    [() => tree.value, () => props.defaultCheckedKeys],\n    () => {\n      return nextTick(() => {\n        _setCheckedKeys(props.defaultCheckedKeys)\n      })\n    },\n    {\n      immediate: true,\n    }\n  )\n\n  const updateCheckedKeys = () => {\n    if (!tree.value || !props.showCheckbox || props.checkStrictly) {\n      return\n    }\n    const { levelTreeNodeMap, maxLevel } = tree.value\n    const checkedKeySet = checkedKeys.value\n    const indeterminateKeySet = new Set<TreeKey>()\n    // It is easier to determine the indeterminate state by\n    // traversing from bottom to top\n    // leaf nodes not have indeterminate status and can be skipped\n    for (let level = maxLevel; level >= 1; --level) {\n      const nodes = levelTreeNodeMap.get(level)\n      if (!nodes) continue\n      nodes.forEach((node) => {\n        const children = node.children\n        let isEffectivelyChecked =\n          !node.isLeaf || node.disabled || checkedKeySet.has(node.key)\n        if (children) {\n          // Whether all child nodes are selected\n          let allChecked = true\n          // Whether a child node is selected\n          let hasChecked = false\n          for (const childNode of children) {\n            const key = childNode.key\n            if (!childNode.isEffectivelyChecked) {\n              isEffectivelyChecked = false\n            }\n            if (checkedKeySet.has(key)) {\n              hasChecked = true\n            } else if (indeterminateKeySet.has(key)) {\n              allChecked = false\n              hasChecked = true\n              break\n            } else {\n              allChecked = false\n            }\n          }\n          if (allChecked) {\n            checkedKeySet.add(node.key)\n          } else if (hasChecked) {\n            indeterminateKeySet.add(node.key)\n            checkedKeySet.delete(node.key)\n          } else {\n            checkedKeySet.delete(node.key)\n            indeterminateKeySet.delete(node.key)\n          }\n        }\n        node.isEffectivelyChecked = isEffectivelyChecked\n      })\n    }\n    indeterminateKeys.value = indeterminateKeySet\n  }\n\n  const isChecked = (node: TreeNode) => checkedKeys.value.has(node.key)\n\n  const isIndeterminate = (node: TreeNode) =>\n    indeterminateKeys.value.has(node.key)\n\n  const toggleCheckbox = (\n    node: TreeNode,\n    isChecked: CheckboxValueType,\n    nodeClick = true,\n    immediateUpdate = true\n  ) => {\n    const checkedKeySet = checkedKeys.value\n    const children = node.children\n    if (!props.checkStrictly && nodeClick && children?.length) {\n      isChecked = children.some((node) => !node.isEffectivelyChecked)\n    }\n\n    const toggle = (node: TreeNode, checked: CheckboxValueType) => {\n      checkedKeySet[checked ? SetOperationEnum.ADD : SetOperationEnum.DELETE](\n        node.key\n      )\n      const children = node.children\n      if (!props.checkStrictly && children) {\n        children.forEach((childNode) => {\n          if (!childNode.disabled || childNode.children) {\n            toggle(childNode, checked)\n          }\n        })\n      }\n    }\n    toggle(node, isChecked)\n    if (immediateUpdate) {\n      updateCheckedKeys()\n    }\n    if (nodeClick) {\n      afterNodeCheck(node, isChecked)\n    }\n  }\n\n  const afterNodeCheck = (node: TreeNode, checked: CheckboxValueType) => {\n    const { checkedNodes, checkedKeys } = getChecked()\n    const { halfCheckedNodes, halfCheckedKeys } = getHalfChecked()\n    emit(NODE_CHECK, node.data, {\n      checkedKeys,\n      checkedNodes,\n      halfCheckedKeys,\n      halfCheckedNodes,\n    })\n    emit(NODE_CHECK_CHANGE, node.data, checked)\n  }\n\n  // expose\n  function getCheckedKeys(leafOnly = false): TreeKey[] {\n    return getChecked(leafOnly).checkedKeys\n  }\n\n  function getCheckedNodes(leafOnly = false): TreeNodeData[] {\n    return getChecked(leafOnly).checkedNodes\n  }\n\n  function getHalfCheckedKeys(): TreeKey[] {\n    return getHalfChecked().halfCheckedKeys\n  }\n\n  function getHalfCheckedNodes(): TreeNodeData[] {\n    return getHalfChecked().halfCheckedNodes\n  }\n\n  function getChecked(leafOnly = false): {\n    checkedKeys: TreeKey[]\n    checkedNodes: TreeNodeData[]\n  } {\n    const checkedNodes: TreeNodeData[] = []\n    const keys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      checkedKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node && (!leafOnly || (leafOnly && node.isLeaf))) {\n          keys.push(key)\n          checkedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      checkedKeys: keys,\n      checkedNodes,\n    }\n  }\n\n  function getHalfChecked(): {\n    halfCheckedKeys: TreeKey[]\n    halfCheckedNodes: TreeNodeData[]\n  } {\n    const halfCheckedNodes: TreeNodeData[] = []\n    const halfCheckedKeys: TreeKey[] = []\n    if (tree?.value && props.showCheckbox) {\n      const { treeNodeMap } = tree.value\n      indeterminateKeys.value.forEach((key) => {\n        const node = treeNodeMap.get(key)\n        if (node) {\n          halfCheckedKeys.push(key)\n          halfCheckedNodes.push(node.data)\n        }\n      })\n    }\n    return {\n      halfCheckedNodes,\n      halfCheckedKeys,\n    }\n  }\n\n  function setCheckedKeys(keys: TreeKey[]) {\n    checkedKeys.value.clear()\n    indeterminateKeys.value.clear()\n    nextTick(() => {\n      _setCheckedKeys(keys)\n    })\n  }\n\n  function setChecked(key: TreeKey, isChecked: boolean) {\n    if (tree?.value && props.showCheckbox) {\n      const node = tree.value.treeNodeMap.get(key)\n      if (node) {\n        toggleCheckbox(node, isChecked, false)\n      }\n    }\n  }\n\n  function _setCheckedKeys(keys: TreeKey[]) {\n    if (tree?.value) {\n      const { treeNodeMap } = tree.value\n      if (props.showCheckbox && treeNodeMap && keys?.length > 0) {\n        for (const key of keys) {\n          const node = treeNodeMap.get(key)\n          if (node && !isChecked(node)) {\n            toggleCheckbox(node, true, false, false)\n          }\n        }\n        updateCheckedKeys()\n      }\n    }\n  }\n\n  return {\n    updateCheckedKeys,\n    toggleCheckbox,\n    isChecked,\n    isIndeterminate,\n    // expose\n    getCheckedKeys,\n    getCheckedNodes,\n    getHalfCheckedKeys,\n    getHalfCheckedNodes,\n    setChecked,\n    setCheckedKeys,\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}