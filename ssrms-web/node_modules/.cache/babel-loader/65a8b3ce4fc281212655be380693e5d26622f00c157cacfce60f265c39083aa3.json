{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport { isArray } from '@vue/shared';\nconst TEXT_ALIGN_RATIO_MAP = {\n  left: [0, 0.5],\n  start: [0, 0.5],\n  center: [0.5, 0],\n  right: [1, -0.5],\n  end: [1, -0.5]\n};\nfunction prepareCanvas(width, height, ratio = 1) {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\");\n  const realWidth = width * ratio;\n  const realHeight = height * ratio;\n  canvas.setAttribute(\"width\", `${realWidth}px`);\n  canvas.setAttribute(\"height\", `${realHeight}px`);\n  ctx.save();\n  return [ctx, canvas, realWidth, realHeight];\n}\nfunction useClips() {\n  function getClips(content, rotate, ratio, width, height, font, gapX, gapY, space) {\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(width, height, ratio);\n    let baselineOffset = 0;\n    if (content instanceof HTMLImageElement) {\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight);\n    } else {\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign,\n        textBaseline\n      } = font;\n      const mergedFontSize = Number(fontSize) * ratio;\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`;\n      ctx.fillStyle = color;\n      ctx.textAlign = textAlign;\n      ctx.textBaseline = textBaseline;\n      const contents = isArray(content) ? content : [content];\n      if (textBaseline !== \"top\" && contents[0]) {\n        const argumentMetrics = ctx.measureText(contents[0]);\n        ctx.textBaseline = \"top\";\n        const topMetrics = ctx.measureText(contents[0]);\n        baselineOffset = argumentMetrics.actualBoundingBoxAscent - topMetrics.actualBoundingBoxAscent;\n      }\n      contents == null ? void 0 : contents.forEach((item, index) => {\n        const [alignRatio, spaceRatio] = TEXT_ALIGN_RATIO_MAP[textAlign];\n        ctx.fillText(item != null ? item : \"\", contentWidth * alignRatio + space * spaceRatio, index * (mergedFontSize + font.fontGap * ratio));\n      });\n    }\n    const angle = Math.PI / 180 * Number(rotate);\n    const maxSize = Math.max(width, height);\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio);\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2);\n    rCtx.rotate(angle);\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2);\n    }\n    function getRotatePos(x, y) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle);\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle);\n      return [targetX, targetY];\n    }\n    let left = 0;\n    let right = 0;\n    let top = 0;\n    let bottom = 0;\n    const halfWidth = contentWidth / 2;\n    const halfHeight = contentHeight / 2;\n    const points = [[0 - halfWidth, 0 - halfHeight], [0 + halfWidth, 0 - halfHeight], [0 + halfWidth, 0 + halfHeight], [0 - halfWidth, 0 + halfHeight]];\n    points.forEach(([x, y]) => {\n      const [targetX, targetY] = getRotatePos(x, y);\n      left = Math.min(left, targetX);\n      right = Math.max(right, targetX);\n      top = Math.min(top, targetY);\n      bottom = Math.max(bottom, targetY);\n    });\n    const cutLeft = left + realMaxSize / 2;\n    const cutTop = top + realMaxSize / 2;\n    const cutWidth = right - left;\n    const cutHeight = bottom - top;\n    const realGapX = gapX * ratio;\n    const realGapY = gapY * ratio;\n    const filledWidth = (cutWidth + realGapX) * 2;\n    const filledHeight = cutHeight + realGapY;\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight);\n    function drawImg(targetX = 0, targetY = 0) {\n      fCtx.drawImage(rCanvas, cutLeft, cutTop, cutWidth, cutHeight, targetX, targetY + baselineOffset, cutWidth, cutHeight);\n    }\n    drawImg();\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2);\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2);\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio];\n  }\n  return getClips;\n}\nexport { useClips as default };","map":{"version":3,"names":["TEXT_ALIGN_RATIO_MAP","left","start","center","right","end","prepareCanvas","width","height","ratio","canvas","document","createElement","ctx","getContext","realWidth","realHeight","setAttribute","save","useClips","getClips","content","rotate","font","gapX","gapY","space","contentWidth","contentHeight","baselineOffset","HTMLImageElement","drawImage","color","fontSize","fontStyle","fontWeight","fontFamily","textAlign","textBaseline","mergedFontSize","Number","fillStyle","contents","isArray","argumentMetrics","measureText","topMetrics","actualBoundingBoxAscent","forEach","item","index","alignRatio","spaceRatio","fillText","fontGap","angle","Math","PI","maxSize","max","rCtx","rCanvas","realMaxSize","translate","getRotatePos","x","y","targetX","cos","sin","targetY","top","bottom","halfWidth","halfHeight","points","min","cutLeft","cutTop","cutWidth","cutHeight","realGapX","realGapY","filledWidth","filledHeight","fCtx","fCanvas","drawImg","toDataURL"],"sources":["../../../../../../packages/components/watermark/src/useClips.ts"],"sourcesContent":["import { isArray } from '@element-plus/utils'\n\nimport type { WatermarkProps } from './watermark'\n\n// [alignRatio, spaceRatio]\nconst TEXT_ALIGN_RATIO_MAP = {\n  left: [0, 0.5],\n  start: [0, 0.5],\n  center: [0.5, 0],\n  right: [1, -0.5],\n  end: [1, -0.5],\n} as const\n\nfunction prepareCanvas(\n  width: number,\n  height: number,\n  ratio = 1\n): [\n  ctx: CanvasRenderingContext2D,\n  canvas: HTMLCanvasElement,\n  realWidth: number,\n  realHeight: number,\n] {\n  const canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')!\n  const realWidth = width * ratio\n  const realHeight = height * ratio\n  canvas.setAttribute('width', `${realWidth}px`)\n  canvas.setAttribute('height', `${realHeight}px`)\n  ctx.save()\n\n  return [ctx, canvas, realWidth, realHeight]\n}\n\n/**\n * Get the clips of text content.\n * This is a lazy hook function since SSR no need this\n */\nexport default function useClips() {\n  // Get single clips\n  function getClips(\n    content: NonNullable<WatermarkProps['content']> | HTMLImageElement,\n    rotate: number,\n    ratio: number,\n    width: number,\n    height: number,\n    font: Required<NonNullable<WatermarkProps['font']>>,\n    gapX: number,\n    gapY: number,\n    space: number\n  ): [dataURL: string, finalWidth: number, finalHeight: number] {\n    // ================= Text / Image =================\n    const [ctx, canvas, contentWidth, contentHeight] = prepareCanvas(\n      width,\n      height,\n      ratio\n    )\n    let baselineOffset = 0\n    if (content instanceof HTMLImageElement) {\n      // Image\n      ctx.drawImage(content, 0, 0, contentWidth, contentHeight)\n    } else {\n      // Text\n      const {\n        color,\n        fontSize,\n        fontStyle,\n        fontWeight,\n        fontFamily,\n        textAlign,\n        textBaseline,\n      } = font\n      const mergedFontSize = Number(fontSize) * ratio\n\n      ctx.font = `${fontStyle} normal ${fontWeight} ${mergedFontSize}px/${height}px ${fontFamily}`\n      ctx.fillStyle = color\n      ctx.textAlign = textAlign\n      ctx.textBaseline = textBaseline\n      const contents = isArray(content) ? content : [content]\n      if (textBaseline !== 'top' && contents[0]) {\n        const argumentMetrics = ctx.measureText(contents[0])\n        ctx.textBaseline = 'top'\n        const topMetrics = ctx.measureText(contents[0])\n        baselineOffset =\n          argumentMetrics.actualBoundingBoxAscent -\n          topMetrics.actualBoundingBoxAscent\n      }\n      contents?.forEach((item, index) => {\n        const [alignRatio, spaceRatio] = TEXT_ALIGN_RATIO_MAP[textAlign]\n        ctx.fillText(\n          item ?? '',\n          contentWidth * alignRatio + space * spaceRatio,\n          index * (mergedFontSize + font.fontGap * ratio)\n        )\n      })\n    }\n\n    // ==================== Rotate ====================\n    const angle = (Math.PI / 180) * Number(rotate)\n    const maxSize = Math.max(width, height)\n    const [rCtx, rCanvas, realMaxSize] = prepareCanvas(maxSize, maxSize, ratio)\n\n    // Copy from `ctx` and rotate\n    rCtx.translate(realMaxSize / 2, realMaxSize / 2)\n    rCtx.rotate(angle)\n    if (contentWidth > 0 && contentHeight > 0) {\n      rCtx.drawImage(canvas, -contentWidth / 2, -contentHeight / 2)\n    }\n\n    // Get boundary of rotated text\n    function getRotatePos(x: number, y: number) {\n      const targetX = x * Math.cos(angle) - y * Math.sin(angle)\n      const targetY = x * Math.sin(angle) + y * Math.cos(angle)\n      return [targetX, targetY]\n    }\n\n    let left = 0\n    let right = 0\n    let top = 0\n    let bottom = 0\n\n    const halfWidth = contentWidth / 2\n    const halfHeight = contentHeight / 2\n    const points = [\n      [0 - halfWidth, 0 - halfHeight],\n      [0 + halfWidth, 0 - halfHeight],\n      [0 + halfWidth, 0 + halfHeight],\n      [0 - halfWidth, 0 + halfHeight],\n    ]\n    points.forEach(([x, y]) => {\n      const [targetX, targetY] = getRotatePos(x, y)\n      left = Math.min(left, targetX)\n      right = Math.max(right, targetX)\n      top = Math.min(top, targetY)\n      bottom = Math.max(bottom, targetY)\n    })\n\n    const cutLeft = left + realMaxSize / 2\n    const cutTop = top + realMaxSize / 2\n    const cutWidth = right - left\n    const cutHeight = bottom - top\n\n    // ================ Fill Alternate ================\n    const realGapX = gapX * ratio\n    const realGapY = gapY * ratio\n    const filledWidth = (cutWidth + realGapX) * 2\n    const filledHeight = cutHeight + realGapY\n\n    const [fCtx, fCanvas] = prepareCanvas(filledWidth, filledHeight)\n\n    function drawImg(targetX = 0, targetY = 0) {\n      fCtx.drawImage(\n        rCanvas,\n        cutLeft,\n        cutTop,\n        cutWidth,\n        cutHeight,\n        targetX,\n        targetY + baselineOffset,\n        cutWidth,\n        cutHeight\n      )\n    }\n    drawImg()\n    drawImg(cutWidth + realGapX, -cutHeight / 2 - realGapY / 2)\n    drawImg(cutWidth + realGapX, +cutHeight / 2 + realGapY / 2)\n\n    return [fCanvas.toDataURL(), filledWidth / ratio, filledHeight / ratio]\n  }\n\n  return getClips\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}